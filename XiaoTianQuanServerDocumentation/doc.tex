\documentclass[a4paper,11pt]{report}

    %Use system fonts, only apply to XeTeX
    \usepackage{fontspec}
    \usepackage{xeCJK}
    \setmainfont[Ligatures={TeX}]{Minion Pro}
    \setsansfont[Ligatures={TeX}]{Myriad Pro}
    \setmonofont[Ligatures={TeX}]{Consolas}

    \setCJKmainfont[BoldFont=Adobe Heiti Std,ItalicFont=Adobe Kaiti Std,Ligatures={TeX}]{Adobe Song Std}
    \setCJKfamilyfont{kaiti}[Ligatures={TeX}]{Adobe Kaiti Std}
    \setCJKfamilyfont{sf}[Ligatures={TeX}]{Adobe Heiti Std}
    \setCJKfamilyfont{it}[Ligatures={TeX}]{Adobe Kaiti Std}
    \setCJKfamilyfont{tt}[Ligatures={TeX}]{Adobe Kaiti Std}

    \usepackage{unicode-math}
    \unimathsetup{math-style=TeX}
    \setmathfont{XITS Math}

    %Adjust margin of document
    \usepackage{geometry}
    \geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

    \setlength{\parskip}{12pt}
    \setlength{\parindent}{0pt}

    % Graphics with mpost
    \usepackage{graphicx}
    \DeclareGraphicsRule{*}{eps}{*}{}

    % Hyperref in pdf
    \usepackage[usenames,dvipsnames]{xcolor}
    \usepackage{hyperref}
    \hypersetup{breaklinks,colorlinks,linkcolor=RoyalBlue,citecolor=red,urlcolor=purple,pdfstartview=FitH,pdfauthor={坂本ポテコ},pdftitle={XiaoTianQuan Server User Manual}}

    \usepackage{xspace}

    \newcommand{\method}[1]{\textsf{\textbf{Method:}} #1}
    \newcommand{\params}[1]{\textsf{\textbf{Params:}} \texttt{#1}}
    \newcommand{\accept}[1]{\textsf{\textbf{Accept:}} #1}
    \newcommand{\response}[1]{\textsf{\textbf{Response:}} #1}
    \newcommand{\auth}[1]{\textsf{\textbf{Authorization:}} #1}
	
    \newcommand{\webapi}[6]{
    \method{#1}

    \params{#2}

    \accept{#3}

    \auth{#4}

    #5

    \response{#6}
    }

    \newcommand{\sand}{\textsf{and}\xspace}
    \newcommand{\httppost}{\texttt{POST}}
    \newcommand{\httpget}{\texttt{GET}}
    \newcommand{\httpput}{\texttt{PUT}}
    \newcommand{\httpdelete}{\texttt{DELETE}}
    \newcommand{\json}{\texttt{application/json, text/json}\xspace}
    \newcommand{\xml}{\texttt{application/xml, text/xml}\xspace}
    \newcommand{\querystring}{\texttt{Query String}\xspace}
    \newcommand{\na}{\texttt{N/A}\xspace}
    \newcommand{\true}{\textbf{true}\xspace}
    \newcommand{\false}{\textbf{false}\xspace}
    \newcommand{\ok}{\textbf{200/OK}\xspace}
    \newcommand{\badrequest}{\textbf{400/Bad Request}\xspace}
    \newcommand{\unauth}{\textbf{401/Unauthorized}\xspace}
    \newcommand{\forbidden}{\textbf{403/Forbidden}\xspace}
    \newcommand{\notfound}{\textbf{404/Not Found}\xspace}
    \newcommand{\badgateway}{\textbf{502/Bad Gateway}\xspace}
    \newcommand{\authanno}{Annonymous}
    \newcommand{\authapp}{Application}
    \newcommand{\authuser}{User}
    \newcommand{\typestring}{\textcolor{blue}{string }}
    \newcommand{\typebool}{\textcolor{blue}{bool }}
    \newcommand{\typeint}{\textcolor{blue}{int }}
    \newcommand{\typelist}[1]{\textcolor{blue}{list #1}}
    \newcommand{\notimplemented}{\texttt{\textcolor{Apricot}{throw new} \textcolor{Aquamarine}{NotImplementedException}();}}

\begin{document}

\title{\Huge{XiaoTianQuan Server\\ \vspace{1.5em} User Manual}}
\author{坂本ポテコ}
\maketitle
\clearpage

\tableofcontents
\clearpage


{\Huge{Work In Progress.}}

\chapter{Objectives}

XiaoTianQuan Server (the server, or server) is developed as a versatile and flexible vending machine backend for cryptocurrencies.


\section{User Authentication}

MCSI offers user authentication service for mobile apps. User can log in to MCSI \emph{and} MoegirlWiki with MoigirlWiki credentials. Login is required for some services of MCSI.

MCSI does not store user credentials. Username and password are authenticated via MoegirlWiki system. An authentication token will be generated by MCSI when the user is authenticated. The client shall supply with the authentication token in following requests. The login flow is demonstrated below:

\begin{figure}[htbp]
\minipage[b][][b]{\textwidth}
    \includegraphics[width=\linewidth]{Login.eps}
    \caption{Login Flow}
    \label{fig:loginflow}
\endminipage\hfill
\end{figure}

Some services may also require a wiki token. You may acquire a token via RequestWikiToken API (\ref{sec:api:auth:requestwikitoken}). Be advised that some failures of this API indicates an expired wiki login, which will require a login with username and password (\ref{sec:api:auth:wikilogin}).

Client apps are strongly encouraged to adopt the Azure Mobile Service Client and MCSI style login. This provides a much easier way of using the service, and some redundant \emph{``workaround''} APIs of services can be eliminated.

\section{Page Cache}

MCSI caches the XML format of parsed page (response of \texttt{/api.php?action=parse}) of MoegirlWiki. Both zh-cn and zh-tw versions are available. Mobile app may issue a cache expiration request explicitly. MCSI caches the redirected page title as well, which can be found in response header.

\section{Push Notification}

MCSI provides the functionality of managing push endpoints and messages.

Client may register to MCSI with the push notification channel provided by the Operating System. Client may offer tags (for the purpose of filtering notifications) in registration as well.

MCSI can delegate messages via RESTful API. An authenticated third party web app may send notifications through MCSI.

This service supports APNS (iOS), GCM (Android), WNS (Windows Store apps), MPNS (Windows Phone), ADM (Amazon Kindle Fire) and Baidu (Android without Google services).

MCSI offers three kinds of notifications: Alert, Message and OpenPage. An \textsf{Alert} message has only the message body and is the only notification type supported on lower version of iOS (5.x).
A \textsf{Message} contains both title and message. An \texttt{OpenPage} message is simply a \texttt{Message} with a navigation action.

%\begin{figure}[htbp]
%\minipage[b][][b]{\textwidth}
%    \includegraphics[width=\linewidth]{PushNotif.eps}
%    \caption{Push Notification Work Flow}
%    \label{fig:pushnotifflow}
%\endminipage\hfill
%\end{figure}

\section{Editing the Page}

MCSI provides an simple way of editing the page. Clients shall take the following procedure to commit an edit:

\begin{enumerate}
    \item Get the raw wikitext of a page (\ref{sec:api:wiki:edit:getraw}), save the \texttt{Timestamp} field for submitting
    \item Prompt user for editing
    \item Request a wiki token id (\ref{sec:api:auth:requestwikitoken}), save the \texttt{TokenId} field for submitting
    \item Submit the edited page
    \item If the API returns captcha needed, prompt the user for entering the captcha
    \item Submit the edited page with captcha
\end{enumerate}

\section{Authorization}
There are three authorization levels in MCSI: Anonymous, Application and User. API in Anonymous Level can be accessed without any token. Supplied application header is required for Application Level API.

\chapter{API Reference}

\section{api/Auth}

\subsection{api/Auth/WikiLogin}
\label{sec:api:auth:wikilogin}
\webapi
{\httppost}
{\typestring username, \typestring password}
{\json \sand \xml}
{\authapp}
{Log in to MoegirlProxy and MoegirlWiki.}
{
Returns \ok with following content if logged in successfully:
    \begin{quote}
        \begin{description}
          \item[\textsf{\typestring UserId}] MoegirlProxy user ID
          \item[\textsf{\typestring MobileServiceAuthenticationToken}] MoegirlProxy user auth token
          \item[\textsf{\typestring moegirlSSOUserID}] moegirlSSOUserID cookie
          \item[\textsf{\typestring moegirlSSOUserName}] moegirlSSOUserName cookie
          \item[\textsf{\typestring moegirlSSOToken}] moegirlSSOToken cookie
        \end{description}
    \end{quote}

Client shall save all returned fields for future use.

Returns \unauth when the username and password combination is incorrect, and \badgateway when upstream server fails.
}


\subsection{api/Auth/IsLoggedIn}
\webapi
{\httpget}
{N/A}
{\na}
{\authuser}
{Test if current user of Azure Mobile Service Client is logged in.}
{Returns \ok with content \true if current user is logged in, else returns \unauth.

\textbf{Note: } An \ok response does not necessarily mean the login is still valid in MoegirlWiki system (cookie may be expired).
To test if the login is still valid on MoegirlWiki system, call RequestWikiToken (\ref{sec:api:auth:requestwikitoken}).
}

\subsection{api/Auth/RequestWikiToken}
\label{sec:api:auth:requestwikitoken}
\webapi
{\httppost}
{\typestring moegirlSSOUserId, \typestring moegirlSSOUserName, \typestring moegirlSSOToken}
{\json \sand \xml}
{\authuser}
{Create a token of MoegirlWiki. The token and cookies will be stored in MCSI till the token expires (default 4 hours). }
{Returns \ok with token id \texttt{TokenId} in content if the operation completed successfully. If upstream server fails or returns bad response, \badgateway will be returned.
\forbidden will be returned if the wiki login has expired.}

\section{api/Cache}

\subsection{api/Cache/Page/[lang = zh-cn]}
\webapi
{\httpget}
{\typestring title, [\typebool refresh = false]}
{\querystring}
{\authanno}
{Retrieve the cached page. \texttt{refresh} invalidates the current cache and page retrieved from upstream will be returned. \texttt{lang} can be either \texttt{zh-cn} or \texttt{zh-tw}. You may safely ignore this parameter.

The response headers contains following fields:
\begin{quote}
    \begin{description}
        \item[\textsf{ZMoeProxy-Cache}] Hit, Expired or Missed
        \item[\textsf{ZMoeProxy-Title}] The redirected page title, in encoded url form
        \item[\textsf{ZMoeProxy-LastUpdated}] Timestamp of last update
    \end{description}
\end{quote}
}
{The retrieved page in XML format. \ok will be returned.}

\subsection{api/Cache/Page}
\webapi
{\httpput}
{\typestring title}
{\na}
{\authapp}
{Add the page to invalidation queue. Both page cache with title \texttt{title} and redirected title \texttt{title} will be invalidated. Invalidation job is executed periodically.}
{\ok if success.}

\subsection{api/Cahce/Page}
\webapi
{\httpdelete}
{\typestring title}
{\na}
{\authapp}
{Delete the page cache.}
{\ok if success.}

\subsection{api/Cache/Template}
\webapi
{\httpput}
{\typestring template}
{\na}
{\authapp}
{Add \texttt{template} to template invalidation queue. All pages who reference \texttt{template} will be invalidated. Invalidation job is executed periodically.}
{\ok if success.}

\section{api/Notification}

\subsection{api/Notification/Register/APNS}
\webapi
{\httppost}
{\typestring Handle, \typestring DeviceId, [\typestring Username], [\typelist \typestring Tags]}
{\json \sand \xml}
{\authapp}
{Register APNS \texttt{Handle} with the notification service. \texttt{DeviceId} is the unique ID bound to per user per device. At least one \texttt{Tags} or \texttt{Username} shall be supplied.}
{\ok with registration info if success. Registration info contains \texttt{RegistrationId} field, which should be recorded for preventing multiple registration with the same \texttt{Handle}.}

\subsection{api/Notification/Watchlist}
\webapi
{\httppost}
{\typestring Title, \typelist{\typestring} Users, \typestring Action}
{\json \sand \xml}
{\authapp}
{Add page \texttt{Title} to notification list. \texttt{Users} are users watching the page. \texttt{Action} can be either \texttt{Edit}, \texttt{Move} or \texttt{Delete}}
{\ok if success. \badrequest if the parameters are malformed.}

\subsection{api/Notification/Send/Alet}
\webapi
{\httppost}
{\typestring Message, [\typestring TagExpression]}
{\json \sand \xml}
{\authapp}
{Push an alert to clients. The alert will be sent to all clients if \texttt{TagExpression} is left null.}
{\ok with result if success.}

\subsection{api/Notification/Send/Message}
\webapi
{\httppost}
{\typestring Title, \typestring Body, [\typestring TagExpression]}
{\json \sand \xml}
{\authapp}
{Push an message to clients. The message will be sent to all clients if \texttt{TagExpression} is left null.}
{\ok with result if success.}

\subsection{api/Notification/Send/OpenPage}
\webapi
{\httppost}
{\typestring Title, \typestring Body, \typestring Uri, [\typestring TagExpression]}
{\json \sand \xml}
{\authapp}
{Push an message with action of opening the page to clients. The message will be sent to all clients if \texttt{TagExpression} is left null.}
{\ok with result if success.}

\section{api/Wiki/Edit}
\subsection{api/Wiki/Edit/GetRaw}
\label{sec:api:wiki:edit:getraw}
\webapi
{\httpget}
{\typestring Title}
{\querystring}
{\authapp}
{Get the raw wikitext and supplementary information of a page.}
{\ok if success. The response contains following fields:

\begin{description}
  \item[\textsf{\typestring Title}] Title of the page
  \item[\textsf{\typestring Timestamp}] Timestamp of the page. Keep it as string. You'll need it when submit an edit
  \item[\textsf{\typestring Text}] The wikitext of the page
\end{description}

\notfound will be returned if the page does not exsit. \badgateway indicates an invalid response from or a failure of upstream server.
}

\subsection{api/Wiki/Edit/Submit}
\label{sec:api:wiki:edit:submit}
\webapi
{\httppost}
{\typestring TokenId, \typestring Title, \typestring Text, \typebool IsMinor, \typestring BaseTimestamp, \typestring summary, [\typestring CaptchaId], [\typestring CaptchaAnswer]}
{\json \sand \xml}
{\authuser}
{Submit an edit. \texttt{BaseTimestamp} is \texttt{Timestamp} returned by GetRaw API (\ref{sec:api:wiki:edit:getraw}) in \emph{ISO 8601 format}, specifically, C\# format string \texttt{yyyy-MM-ddTHH:mm:ssZ}.}
{

\textbf{NOTE: This API may return \ok even if the edit was not comitted.}

\forbidden will be returned if the TokenId is invalid or expired. \badgateway will be returned if the upstream server fails or responds invalid message.

An \ok response contains at least \texttt{Result} and \texttt{HasCaptcha} fields. \texttt{Result} indicates a failure or success. When the edit is successfully committed, \texttt{Result} would be \texttt{Success}. In the case of the captcha is required, \texttt{Result} would be \texttt{Failure}, \texttt{HasCaptcha} would be true while additional \texttt{CaptchaId} and \texttt{CaptchaQuestion} fields will be provided. The client shall save \texttt{CaptchaId} and prompt the user for entering the captcha. All other \texttt{Result} values indicate the failure.

The token, i.e. \texttt{TokenId}, will be invalidated after a successful commit. You may reuse the token as long as this API fails and no other API invalidates it.
}

\end{document}


















